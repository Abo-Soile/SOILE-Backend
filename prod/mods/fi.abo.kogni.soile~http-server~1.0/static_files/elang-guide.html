<!DOCTYPE html><html><head><meta charset="utf-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px 12px;}
pre code { border: 0px !important; padding: 0;}
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>elang-guide</title></head><body><h1 id="elang-documentation">Elang Documentation</h1>
<p>This document contains documentation for the experiment language.</p>
<h2 id="structure">Structure</h2>
<p>The following structure is enforced on programs:</p>
<ul>
<li>Val and gvar definiton block</li>
<li>Function definiton block</li>
<li>Phase definition block</li>
<li>Transition block</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>#Val and gvar definition block"
gvar g1 &lt;- "global var"
gvar g2 &lt;- 56
val a &lt;- "a"
.
.
.
#end of block

#Function definition block 
function test()
  helptext("test")
end

function helloworld()
  showmsg("Hello world")
 end
 .
 .
 .
#end of function block

#Phase definitions
intermezzo-phase phase1
  showmsg("In phase1")
  wait(5000)
end

information-phase phase2
  showmsg("In phase2")
  wait(5000)
end

intermezzo-phase phase3
  showmsg("In phase3")
  wait(5000)
end
#End of phase definitionsd


#Transition definations
transition
  start(phase1)
  phase1 -&gt; phase2
  phase2 -&gt; phase3
  final(phase3)
end

##End of program
</code></pre>
<h2 id="variables">Variables</h2>
<p>Variables are containers that can store a value. A variable is created by using the approperiate keyword and assigning a value to it. "val a &lt;- "abc" creates a variable named a that contains the value "abc". The value can then be used by using the variables name. Variable definitions should be in the beginning of a function.</p>
<pre><code>var a &lt;- "abc"
showmsg(a)  # Displays abc on the screen
</code></pre>
<p>A existing variable can be given a new value by using the assignment operator &lt;-. </p>
<pre><code>var a &lt;- 41  # a contains the number 41
a &lt;- 66      # 66 is assign to a, the old value(41) is forgotten
</code></pre>
<p>There are three different types of variables; </p>
<ul>
<li><strong>gvar</strong> Global variable, useable everywhere</li>
<li><strong>val</strong> static global value, cannot be modified after definition</li>
<li><strong>var</strong> Normal variable, usable only inside the function/phase where it's defined.</li>
</ul>
<p>.</p>
<pre><code>gvar a &lt;- 55

information-phase Phase1
  var b &lt;- "Variable b" 
  #Both  a and b are visible here
end

information-phse Phase2
  # A is visible but b isn't
end
</code></pre>
<h2 id="values">Values</h2>
<h2 id="phases-and-transitions">Phases and transitions</h2>
<p>Program flow is contolled with phases and phase trasnsitions. There are two types of phases; intermezzo-phases and interaction phases. The intermezzo phase is more simple and is just run from the beginning to the end while the interaction phase has more support for repeating actions. Phases are defined with the correscponding keyword followed a name, and the phases is anded with the <strong>end</strong> command.</p>
<pre><code>#Simple intermezzo phase definition
intermezzo-phase FirstPhase
  # Doing stuff
  # Moar stuff
  # Even moar stuff
end
</code></pre>
<p>The interaction phase as some mandatory extra control structures, enterphase, leavephase, beforeiteration, afteriteration and iteration. Commands inside enterphase are run once when the phase starts and leavephase behaves in the same way when the phase ends.</p>
<p>A set of stimuli should be defined in each iterationphase, usually in enterphase using the setstimuli() function. The set stimuli function accepts an array with stimuliobjects and iteration is run once for each object. Before and afteriteration are run before/after each iteration and can be used for example tio store data and clean up after an iteration/ prepare for the next iteration. See the stimuli topic for more information.</p>
<pre><code>interaction-phase MainPhase
    enterphase
        showmsg("Entering phase")
        # Setting two stimuli, 1 and 2
        setstimuli([1 2)])  
    end

    leavephase
        showmsg("Leaving phase")
    end

    beforeiteration
        showmsg("Start iteration")
    end

    afteriteration
        showmsg("End iteration")
    end

    iteration
        # Stimulus returns the current stimuli, 1 in the first iteration
        # and 2 in the second one.
        showmsg(append("Stimulus nr " stimulus()))
    end
end

# Output:
# Entering phase
# Start iteration
# Stimulus nr 1
# End iteration
# Start iteration
# Stimulus nr 2
# End iteration
# Leaving phase
</code></pre>
<h2 id="functions">Functions</h2>
<h2 id="builtin-functions">Builtin functions</h2>
<p>Builtin functions are functions that are called and executed from a experiment by the user. </p>
<h3 id="display">Display</h3>
<p>Display positions are defined as the number of pixels from the top-left corner of the display. Positions are defined as a json object with two variables; top and left, .e.g. the position {top:50 left:100} is located 100 pixels to the right and 50 pixels below the topleft corner. </p>
<p><strong>show(displayobject position)</strong>
Displays an object at the specified position.</p>
<p><strong>hide(displayobject)</strong>
Hides the specified object.</p>
<h4 id="displayobjects">DisplayObjects</h4>
<p>All displayobjects share the same functionality regarding showing and hidning them. And they must be defined and assigned to a varriable before being used. </p>
<p><strong>msgbox(message, fontsize=20)</strong>
Displayobject for displaying text at any location. Fontsize is an optional argument and it defaults to 20</p>
<p><strong>imagefile(imageurl)</strong>
Object containing a image specified by the url, so images can either be uploaded to the testeditor or fetched from the internet. Note that images on the net can disappear or change at any time.  The image is displayed without any scaling so make sure that the image is the right size. </p>
<p><strong>rectangle(width height borderwidth=2)</strong>
Displays a rectangle with the given width height and borderwidth. Borderwidth is an optional argument and defaults to 2. </p>
<p>It's also possible to display simple text messages using showmsg(message) and hidemsg() without any further specifications. This just shows/hides a message at location {top:50 left:50}</p>
<p><strong>showmsg(message)</strong>
Displays a message at the standard message location in the top right corner</p>
<p><strong>hidemsg()</strong>
Hides the standard message.</p>
<h3 id="input">Input</h3>
<h4 id="mouse">Mouse</h4>
<p><strong>onmouseclick(imagefile, {action: function, inputid: number, resettimer: bool})</strong></p>
<p>Creates a mouseclick listener for the object/image, which will be triggered when the image is clicked. The function specified in "action" is executed on each click. </p>
<p><strong>onmouseclick(imagefile, false)</strong></p>
<p>Removes all mouseclick functions bound to the specified object.</p>
<h4 id="keyboard">Keyboard</h4>
<p><strong>onkeypress(key, func)</strong>
Binds the specified key to a function so that the function is run every time when the key is pressed.</p>
<p><strong>onkeypress(key)</strong>
Removes all actionss bound to the specified key.</p>
<pre><code>function leftclick()
    showmsg("left was clicked")
end

onkeypress("left", leftclick)
</code></pre>
<p>Example: the function leftclick is run each time when the left arrow is clicked on the keyboard.</p>
<p><strong>onanykey(func ignore=[])</strong>
Runs the specified function on all keypresses.</p>
<p><strong>onanykey(func ignore="")</strong>
Executes the specified function when any keyboeard key except keys specified ignore are pressed. Ignored keys should be sent as an array of individual keynames, for example ["a" "enter"] ignores the keys <strong>a</strong> and <strong>enter</strong>, see the keycode table for the correct key names. </p>
<p>Ignore can also accept a special command "onlyletters" which ignores everything but a-z.
    onanykey(resume() "onlyletters").</p>
<p><strong>onanykey()</strong>
Removes all actions bound with <strong>onanykey</strong></p>
<p><strong>resumeonkey(keycode)</strong>
Runs resume() once when the specified key is clicked. </p>
<p><strong>resumeonkey()</strong>
Runs resume() on any keypress once. </p>
<p><strong>getlastkey()</strong>
Returns the most recent keypress as a string. </p>
<h3 id="arithmetic">Arithmetic</h3>
<h4 id="basic">Basic</h4>
<p><strong>plus(number1 number2)</strong> number1 + number2</p>
<p><strong>minus(number1 number2)</strong> number1 - number2</p>
<p><strong>multiply(number1 number2)</strong> number1 * number2</p>
<p><strong>divide(number1 number2)</strong> number1 / number2</p>
<h4 id="logic">Logic</h4>
<p><strong>not(boolean)</strong></p>
<p><strong>and(bool1 bool2)</strong></p>
<p><strong>or(bool1 bool2)</strong></p>
<p><strong>lessthan(number1 number2 <em>or</em> lt(number1 number2))</strong> number1 &lt; number2</p>
<p><strong>greaterthan(number1 number2) <em>or</em> gt(number1 number2)</strong> number1 &gt; number2</p>
<p><strong>equal(number1 number2) <em>or</em> eq(number1 number2)</strong> number1 == number2</p>
<h3 id="functions_1">Functions</h3>
<p><strong>append(string1 string2)</strong>
Appends two strings</p>
<p><strong>lenght(object)</strong>
Returns the number of elements/letters in a array or string</p>
<p><strong>elementatindex(object, index)</strong>
Returns the element at the specified index in the object/string, starting from zero.</p>
<h4 id="random-numbers">Random numbers</h4>
<p><strong>randominteger(min, max)</strong>
returns a pseudorandom non decimal number within the range.</p>
<p><strong>randomnumber(min, max)</strong>
Returns a pseudorandom number value within the range</p>
<p><strong>seedrandom(seed)</strong>
Seeds the random generator with  a value. A certain seed will always produce the same sequence of random values. </p>
<h4 id="time-and-timers">Time and timers</h4>
<p><strong>recordts()</strong>
Returns a timestamp with the current time with m,illisecond precision. Timestamps can easily be compared with basic arithmetic operations.</p>
<p><strong>starttimer()</strong>
Starts the timer.</p>
<p><strong>elapsedtime()</strong>
Returns time elapsed, in ms, since the last call top starttimer. Returns 0 if no timer has been started. </p>
<h4 id="result-storage">Result storage</h4>
<p>Results are stored in two tables, raw data and aggregated data. The aggregated data will only produce one row per user while any number of rows can be used for raw data. </p>
<p><strong>storeSingle(field data)</strong></p>
<p>Stores a single value with the specified fieldname in the aggregated datatable. </p>
<p><strong>storeRow(string field data)</strong></p>
<p>Stores a value with the given fieldname in the current raw datarow. </p>
<p><strong>newRow()</strong>
Creates a new empty row to write raw data to.</p>
<h5 id="data-processing-and-aggregation">Data processing and aggregation</h5>
<p>Raw data can be processed to something more usable. An aggregation function loops through the whole raw data table and performs the specified function on every field that it finds. Rows that don't have any value in the specific field are simply omitted. Results are stored in the processed data table in the fi</p>
<p><strong>count(field)</strong></p>
<p>Counts how many rows contain the specific field.</p>
<p><strong>count(field, value)</strong></p>
<p>Counts how many rows contain a specific field with a specific value.</p>
<p><strong>average(field)</strong></p>
<p>Computes the average value from all rows containing this field.</p>
<pre><code>Not implemented yet
median(field)
sum(field)
</code></pre>
<h2 id="rt-runtime-functions">RT - Runtime functions</h2>
<p>Rt functions operate within the vm and should not be called by users. They are only used to manage and run the vm.</p></body></html>