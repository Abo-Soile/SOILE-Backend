var SOILE2;

if (SOILE2 !== undefined){
  throw new Error('SOILE2 already defined!');
}

SOILE2 = (function(){
  'use strict';

  var soile2 = {};
  var bin = {},        // builtin
      rt = {},         // runtime
      defs = {},       // definitions (gvars, vals, functions)
      util = {};       // miscellaneous utility functions
  
  bin.hide = function(id){
    id = soile2.util.getid(id);
    $(id).css('display', 'none');
  };
  
  bin.imagefile = function(id){
    
  };
  
  bin.setstimuli = function(arr){
    if (jQuery.isArray(arr)) {
      soile2.rt.stimuli = soile2.util.copyobject(arr);
      
      /*
       * We will reverse the array so that we can 
       * pop the elements starting from the end.
       */
      soile2.rt.stimuli.reverse();
    }
  };
  
  bin.stimulus = undefined;
  
  bin.show = function(id){
    id = soile2.util.getid(id);
    $(id).css('display', 'block');
  };
  
  rt.finalize_defs = function(){
    this.freeze(soile2.defs.gvars);
    this.freeze(soile2.defs.vals);
    this.freeze(soile2.defs.fns);
    this.freeze(soile2.defs.gen);
  };
  
  rt.freeze = (function(){
    if (Object.freeze !== undefined || typeof Object.freeze === 'function') {
      return function(obj){
        return Object.freeze(obj);
      };
    }
    return function(obj){
      return obj;
    };
  })();
  
  rt.truthvalue = function(value){
    // http://stackoverflow.com/questions/7615214/in-javascript-why-is-0-equal-to-false-but-not-false-by-itself
    // http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/
    
    if (value === false || value === null || value === undefined){
      return false;
    }
    return true;
  };
  
  rt.milliseconds = function(num){
    if (typeof num === 'number'){
      return Math.abs(num);
    }
    if (typeof num === 'string'){
      return Math.abs(parseInt(num, 10));
    }
    return 0;
  };
  
  rt.undefvar = function(name){
    var vars = soile2.defs.vars;
    
    if (vars.hasOwnProperty(name)){
      delete vars[name];
    }
  };
  
  rt.kbdlookup = function(){};
  
  rt.stimuli = [];
  
  rt.has_next_stimulus = function(){
    return (soile2.rt.stimuli.length > 0);
  };
  
  rt.next_stimulus = function(){
    soile2.bin.stimulus = soile2.rt.stimuli.pop();
  };
  
  rt.reset_defs = function(){
    var reset = function(obj, name){
      if (obj.hasOwnProperty(name)){
        delete obj[name];
      }
      obj[name] = {};
    };
    
    reset(soile2.defs, 'gvars');
    reset(soile2.defs, 'vals');
    reset(soile2.defs, 'fns');
    reset(soile2.defs, 'vars');
  };
  
  // Get next "program instruction."
  rt.get_pi = undefined;
  
  // Reset "program instructions."
  rt.reset_piarray = function(){
    soile2.rt.get_pi = function(idx){
      return null;
    };
  };
  
  /*
   * Save "program instructions." Note that we are 
   * assigning a FUNCTION, not an array. The 
   * "program instruction" array is really a 
   * function which closes over an array 
   * (this is for encapsulation).
   */
  rt.set_piarray = function(piafunc){
    soile2.rt.get_pi = piafunc;
  };
  
  /*
   * Execute a program instruction (or several program instructions).
   */
  rt.exec_pi = function(){
    var pi = soile2.rt.get_pi();
    
    if (pi === null){
      return;
    }
    console.log('exec_pi');
  };
  
  rt.resume_exec = function(){
    soile2.rt.exec_pi();
  };
  
  rt.pause_exec = (function(){
    var MINDELAY = 5;
    var due_ts;
    var timeout_id;
    
    var msleft = function(ts){
      return Math.abs(ts - soile2.rt.timestamp());
    };
    
    var keep_waiting = function(ts){
      return (msleft(ts) > MINDELAY);
    };
    
    var compute_delay = function(ts){
      var delay = msleft(ts);
      if (delay < 10){
        return MINDELAY;
      }
      if (delay < 50){
        return MINDELAY * 2;
      }
      if (delay < 100){
        return MINDELAY * 5;
      }
      if (delay < 500){
        return MINDELAY * 10;
      }
      if (delay < 1000){
        return MINDELAY * 15;
      }
      return MINDELAY * 20;
    };
    
    var scheduled = function(){
      if (keep_waiting(due_ts) === true){
        timeout_id = setTimeout(scheduled, compute_delay(due_ts));
        return;
      }
      due_ts = -1;
      timeout_id = undefined;
      soile2.rt.resume_exec();
    };
    
    return function(ms){
      due_ts = soile2.rt.future_timestamp(ms);
      timeout_id = setTimeout(scheduled, compute_delay(due_ts));
    };

  })();
  
  rt.seal = (function(){
    if (Object.seal !== undefined || typeof Object.seal === 'function') {
      return function(obj){
        return Object.seal(obj);
      };
    }
    return function(obj){
      return obj;
    };
  })();
  
  rt.future_timestamp = function(ms) {
    return (soile2.rt.timestamp() + ms);
  };
  
  rt.timestamp = (function(){
    // http://stackoverflow.com/questions/221294/how-do-you-get-a-timestamp-in-javascript
    if (Date.now !== undefined && typeof Date.now == 'function') {
      return function(){
        return Date.now();
      };
    }
    return function(){
      return (new Date()).getTime();
    };
  })();

  // High-level utility functions.
  
  util.copyobject = function(oldObject){
    // https://github.com/douglascrockford/JSON-js
    // http://bestiejs.github.io/json3/
    
    /*
     * We copy an object, or an array, by first serializing 
     * it into a JSON string, and then de-serializing it.
     * It may not be the most efficient way, but it is 
     * conceptually simple and clear.
     * 
     * We assume that the objects we copy do not contain
     * functions. They would be lost in the 
     * serializing process.
     */
    return JSON.parse(JSON.stringify(oldObject));
  };
  
  util.eval = function(code){
    jQuery.globalEval(code);
  };
  
  util.getid = function(s) {
    if (typeof s === 'string') {
      if (s.charAt(0) === '#') {
        return s;
      }
      return '#'.concat(s);
    }
    return s;
  };

  soile2.defs = defs;
  soile2.rt = rt;
  soile2.bin = bin;
  soile2.util = util;
  
  return soile2;
})();
